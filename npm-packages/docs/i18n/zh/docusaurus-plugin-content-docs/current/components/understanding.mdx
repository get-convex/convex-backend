---
title: "理解组件"
slug: "understanding"
sidebar_position: 10
description: "理解组件"
---

Convex Components 是自包含的后端模块，它把函数、模式和数据打包在一起。它们让你可以为应用添加复杂功能——比如认证、限流或文档协作——而无需从零开始自行实现一切。

如果你做过现代 Web 开发，很可能已经以不同形式接触过类似的概念。Convex Components 的设计灵感来自前端组件、第三方 API 和面向服务的架构。关键区别在于，Convex Components 运行在你的后端中，在具备良好可组合性的同时，还拥有后端服务的持久性和可靠性。

下图展示了在组件生态系统中数据和函数访问的工作方式。从一个元素指向另一个元素的箭头表示该元素可以访问另一个元素的函数或数据。

<p style={{ textAlign: "center" }}>
  <img src="/img/components-diagram.png" alt="组件下拉菜单截图" width={600} />
</p>

### 数据 \{#data\}

与前端组件类似，Convex Components 封装了状态和行为，并对外暴露简洁的接口。不过，这些组件不会把状态存储在内存中，而是可以拥有内部状态机，在不同用户会话之间持久存在、跨用户共享，并且会根据外部输入（例如 webhooks）发生变化。组件可以通过几种方式存储数据：

* 使用带有各自模式验证定义的数据库表。由于 Convex 默认是实时的，数据读取会自动变为响应式更新，而写入会以事务方式提交。
* 文件存储，独立于主应用的文件存储。
* 通过内置函数调度器实现的持久化函数。组件可以调度函数在未来运行，并传递状态。

传统情况下，类库通常需要配置第三方服务来添加有状态的现成功能，但这类方案缺乏将状态存储在同一数据库中所带来的事务性保障。

### 隔离性 \{#isolation\}

与常规的 npm 库类似，Convex 组件包含函数、类型安全，并从你的代码中调用。不过，它们还提供了额外的保证。

* 类似于一个外部服务，组件内部的代码无法读取未显式提供给它的数据。这包括数据库表、文件存储、环境变量、定时函数等。反过来，组件的数据也不能被主应用直接修改，从而实现职责的完全分离。
* 类似于面向服务的架构，组件中的函数在一个隔离的环境中运行，因此对全局变量的写入以及对系统行为的修改不会在组件之间共享。
* 类似于单体架构，数据变更会在跨组件调用时以事务方式提交，而无需考虑复杂的分布式提交协议或数据不一致问题。你永远不会遇到组件已经提交了数据，而调用方代码却回滚的情况。
* 此外，每次对组件的变更调用都是一个与其他调用隔离的子事务，让你可以安全地捕获组件抛出的错误。这也让组件作者在没有竞态条件的情况下更容易推理状态变化，并且可以相信抛出的异常总是会回滚该组件的子事务。[了解更多](/components/using.mdx#transactions)。

### 封装 \{#encapsulation\}

能够对自己的代码进行推理对于扩展代码库规模至关重要。
组件让你可以围绕 API 边界和抽象来进行思考。

* 上面讨论的事务性保证，使得组件的作者和使用者都可以在局部范围内推理数据变更。
* 组件暴露的是显式的 API，而不是直接访问数据库表。数据不变量可以在抽象边界内通过代码强制执行。比如，[aggregate 组件](https://convex.dev/components/aggregate) 可以在内部对数据进行反规范化，[rate limiter](https://convex.dev/components/rate-limiter) 组件可以对其数据进行分片，[push notification](https://convex.dev/components/push-notifications) 组件可以在内部对 API 请求进行批处理，同时仍然保持简单的接口。
* 运行时校验确保所有跨越组件边界的数据都会被校验：包括参数和返回值。和普通的 Convex 函数一样，校验器同时还指定了 TypeScript 类型，在运行时保证的基础上提供端到端的类型支持。