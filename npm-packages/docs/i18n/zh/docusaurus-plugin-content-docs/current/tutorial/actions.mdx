---
title: "Convex 教程：调用外部服务"
sidebar_label: "2. 调用外部服务"
slug: "actions"
sidebar_position: 200
hide_table_of_contents: true
description:
  "使用 Convex 操作函数和 scheduler 调用外部 API，将维基百科摘要集成到你的应用中，扩展你的聊天应用功能。"
---

# Convex 教程：调用外部服务 \{#convex-tutorial-calling-external-services\}

在[上一步](/tutorial/index.mdx)中，你构建了一个完全自包含的聊天应用。数据进，数据出。

为了在提供强一致的数据库事务的同时实现刚才看到的自动响应式更新，Convex 中的查询和变更函数不允许向外部世界发起 `fetch` 调用。

真实的应用没这么简单。它们通常需要直接在后端与互联网的其他服务通信。Convex 也允许你通过 **action** 函数来做到这一点。

Action 函数通过调度任务，让同步引擎可以访问外部世界，然后再通过变更函数把数据写回数据库。

现在让我们的聊天应用更聪明一点：让聊天中的任何人都可以使用 Wikipedia API 获取某个主题的 Wikipedia 摘要。

<div className="center-image" style={{ maxWidth: "560px" }}>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/0bn9RcwOwOQ?si=C5Gvz2Us2H1KIAQu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />
</div>

## 你的第一个 `action` \{#your-first-action\}

**将下面的 `action` 添加到你的 `convex/chat.ts` 文件中。**

```typescript
// highlight-next-line
// 像这样更新你的服务器导入:
// highlight-next-line
import { query, mutation, internalAction } from "./_generated/server";

//...

// highlight-next-line
export const getWikipediaSummary = internalAction({
  // highlight-next-line
  args: { topic: v.string() },
  // highlight-next-line
  handler: async (ctx, args) => {
    // highlight-next-line
    const response = await fetch(
      // highlight-next-line
      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
        // highlight-next-line
        args.topic,
      // highlight-next-line
    );
    // highlight-next-line

    // highlight-next-line
    return getSummaryFromJSON(await response.json());
    // highlight-next-line
  },
  // highlight-next-line
});
// highlight-next-line

// highlight-next-line
function getSummaryFromJSON(data: any) {
  // highlight-next-line
  const firstPageId = Object.keys(data.query.pages)[0];
  // highlight-next-line
  return data.query.pages[firstPageId].extract;
  // highlight-next-line
}
```

让我们一步一步来看：

1. 首先，我们创建了一个新的 Convex 操作函数，名为 `getWikipediaSummary`。
   我们使用了 `internalAction`，因为我们希望这个函数只在 Convex 后端内部使用，
   而不作为公共 API 对外暴露。这个函数会基于指定的主题向 Wikipedia API 发起一个简单的
   fetch 请求。
2. 接下来，我们有一个名为 `getSummaryFromJSON` 的 TypeScript 辅助函数，
   用来从 JSON 响应中提取摘要文本。
3. `getWikipediaSummary` 函数会像调用其他任意 TypeScript 函数一样调用这个辅助函数。

这一切都很好，但我要怎么用它呢？

要在 Convex 仪表盘中快速测试这个函数，访问
[https://dashboard.convex.dev](https://dashboard.convex.dev/deployment/functions)
并进入你的项目。点击左侧导航中的 “Functions”，然后
点击 `getWikipediaSummary` 函数。再点击 “Run Function”。

函数运行器界面会弹出。尝试搜索几个不同的关键词。

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_dashboard_action.mp4" type="video/mp4" />

  运行几个 Wikipedia 查询
</video>

## 将它接入到你的应用中 \{#hooking-it-up-to-your-app\}

我们已经可以调用 Wikipedia 了，但还需要在聊天中显示结果。接下来，把所有部分串联起来。

**像下面这样更新你现有的 `sendMessage` 变更：**

```typescript
// highlight-next-line
// 导入 api 引用
// highlight-next-line
import { api, internal } from "./_generated/api";

//...

export const sendMessage = mutation({
  args: {
    user: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("此 TypeScript 函数正在服务器上运行。");
    await ctx.db.insert("messages", {
      user: args.user,
      body: args.body,
    });

    // highlight-next-line
    // 添加以下代码:
    // highlight-next-line
    if (args.body.startsWith("/wiki")) {
      // highlight-next-line
      // 获取第一个空格之后的字符串
      // highlight-next-line
      const topic = args.body.slice(args.body.indexOf(" ") + 1);
      // highlight-next-line
      await ctx.scheduler.runAfter(0, internal.chat.getWikipediaSummary, {
        // highlight-next-line
        topic,
        // highlight-next-line
      });
      // highlight-next-line
    }
  },
});
```

等一下！这个 `ctx.scheduler` 是怎么回事？Convex 自带一个强大的持久化函数调度器。它是同步引擎的基础组成部分，也是你在 Convex 中协调异步函数的方式。

在变更的场景下，这是调用操作从外部世界获取数据的唯一方式。更妙的是，如果由于某种原因你的变更抛出了异常，那就不会安排任何调度。原因在于变更是事务，而调度本质上只是往数据库里写一条记录，告诉 Convex 在将来的某个时间运行这个函数。

好，所以我们可以调度我们的操作，但我们仍然需要把摘要写回到聊天中。

**让我们回去更新一下我们的 `getWikipediaSummary` 操作：**

```typescript
export const getWikipediaSummary = internalAction({
  args: { topic: v.string() },
  handler: async (ctx, args) => {
    const response = await fetch(
      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
        args.topic,
    );

    // highlight-next-line
    // 用以下代码替换 `return ...`。
    // highlight-next-line
    const summary = getSummaryFromJSON(await response.json());
    // highlight-next-line
    await ctx.scheduler.runAfter(0, api.chat.sendMessage, {
      // highlight-next-line
      user: "Wikipedia",
      // highlight-next-line
      body: summary,
      // highlight-next-line
    });
  },
});
```

就像之前调度该操作一样，我们现在也在调度我们的 `sendMessage` 变更，
把对 Wikipedia 查询的结果发送到我们的聊天中。

继续吧，现在试着玩一玩你的应用！

<video autoPlay playsInline muted loop width="100%">
  <source src="/img/tutorial/tut_wikipedia.mp4" type="video/mp4" />

  与 Wikipedia 聊天
</video>

## 调度器、操作函数和同步引擎 \{#the-scheduler-actions-and-the-sync-engine\}

<div className="center-image" style={{ maxWidth: "900px" }}>
  ![带有操作函数的同步引擎](/img/tutorial/ConvexSyncAction.png)
</div>

查询和变更是与数据库交互的唯一方式，而调度器则让你能够在两者之间配合操作函数构建复杂的工作流。

[操作函数](/functions/actions.mdx) 是类似 AWS Lambda 和 Google Cloud Run 的普通无服务器函数。它们用于搭建诸如调用 AI API 和使用 Vector Store 之类的流程，相当于你的“逃生出口”，用来应对外部世界杂乱无章且几乎没有任何保证的现实情况。

操作函数不是同步引擎的一部分。要与数据库交互，它们必须通过查询和变更函数进行通信。这个限制让 Convex 能够在数据库中强制执行事务性保证，并保持同步引擎的高效与灵活。

为扩展性设计应用的最佳方式是尽量减少在操作函数中完成的工作量。只有那些需要[非确定性](https://en.wikipedia.org/wiki/Deterministic_algorithm) 的部分，比如发起外部 `fetch` 调用，才应该放在其中。让操作函数尽可能小，是构建 Convex 应用最具扩展性的方式，可以实现最高吞吐量。

调度器让你的应用可以将大部分关键逻辑保留在查询和变更中，并将代码组织为在操作函数内外穿梭的工作流。

## 你构建了什么 \{#what-you-built\}

在本节教程中，你实现了一个用于与外部世界交互的操作函数，并使用调度器来触发这项工作。

你了解到，让我们的操作函数保持精简、并将大部分工作放在查询和变更中，是构建可扩展 Convex 后端的基础。

## 下一步 \{#next-up\}

你现在已经了解了 Convex 中最重要的概念。作为一个功能齐全的后端，Convex 能做很多事情，比如[身份验证](/auth.mdx)、[文件存储](/file-storage.mdx)和[搜索](/search.mdx)。你可以根据需要按照文档添加这些功能。

我们刚刚简单谈到了如何让你的应用走上成功之路。随着应用规模扩大，你会遇到新的挑战。让我们在[下一节 →](/tutorial/scale.mdx)中学习如何应对其中的一些挑战。

<CardLink
  className="convex-hero-card"
  item={{
  href: "/tutorial/scale",
  docId: "tutorial/scale",
  label: "扩展你的应用",
}}
/>