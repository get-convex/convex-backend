---
title: "OCC と原子性"
slug: "occ"
hidden: false
sidebar_position: 500
todo: ミューテーションの下に移動するか、インライン化するか、削除（Stack に移動）する
description:
  "Convex における楽観的同時実行制御とトランザクションの原子性"
---

[クエリ](/functions/query-functions.mdx) の節で、Convex における楽観的同時実行制御（OCC）の利用において、決定性が重要であると述べました。このセクションでは、その理由についてさらに詳しく見ていきます。

## Convex Financial, Inc. \{#convex-financial-inc\}

バンキングアプリを構築していて、そのためにデータベースには残高情報を持つ
口座が保存されているとします。ユーザー同士でお金を送り合えるようにしたいので、
あるユーザーの口座から別のユーザーの口座に資金を振り替えるミューテーション
関数を書きます。

このトランザクションのある実行では、まず Alice の口座残高を読み取り、
次に Bob の残高を読み取るかもしれません。そのうえで、Alice の口座から
5ドルを差し引き、同じ 5ドルだけ Bob の残高を増やすことにします。

その擬似コードは次のとおりです：

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
WRITE Bob $16
```

この台帳の残高振替は、これらの書き込み操作が必ず一緒に適用されることを保証する必要がある、典型的なデータベースのシナリオです。どちらか一方の操作だけが成功してしまうと、非常に問題があります。

```
$14 <- READ Alice
$11 <- READ Bob
WRITE Alice $9
*crash* // 銀行から$5が失われる
```

こうしたことが決して起こらないという保証が必要です。そのためにはトランザクションのアトミック性が必要であり、それを Convex が提供します。

データの正しさの問題は、それよりはるかに根深いものです。同じレコードを読み書きする並行トランザクションは、*データレース* を引き起こす可能性があります。

このアプリの場合、私たちが残高を読み取った直後に、誰かが Alice の残高を減らしてしまうことは十分に起こりえます。たとえば、彼女が空港でデビットカードを使って Coke Zero を 3 ドルで購入したのかもしれません。

```
$5 Transfer                           $3 Debit Card Charge
----------------------------------------------------------
$14 <- READ Alice
$11 <- READ Bob
                                        $14 <- READ Alice
                                        WRITE Alice $11
WRITE Alice $9 // コーラがタダに！
WRITE Bob $16
```

この種のデータ競合が起きないように防ぐ必要があります。並行して発生する
競合を扱う方法が必要です。一般的に、よく使われるアプローチが
2つあります。

ほとんどの従来型データベースは *悲観的ロック* 戦略を採用します。（ここでいう悲観的とは、
あらかじめ競合が起こることを前提にして、それを防ごうとする戦略である、
という意味です。）悲観的ロックでは、まず Alice のレコードに対するロックを取得し、
次に Bob のレコードに対するロックを取得する必要があります。そのうえでトランザクションを
実行できます。その際、それらのレコードに触れる必要がある他のトランザクションは、
あなたが処理を完了してすべての書き込みがコミットされるまで待機することが保証されます。

何十年もの経験から、悲観的ロックの欠点はよく理解されており、否定できません。
最大の制約は、現実のネットワークとコンピュータが本質的に信頼できないという事実から
生じます。ロックの保有者が、トランザクションの途中で何らかの理由によりいなくなったり
応答しなくなった場合、そのレコードを変更したい他のすべての処理は無期限に待たされることに
なります。これは問題です。

楽観的並行制御は、その名のとおり楽観的です。トランザクションは成功すると仮定し、
事前に何かをロックすることは気にしません。かなり大胆なやり方です！どうしてそんなに
自信が持てるのでしょうか？

これは、読み取ったレコードのバージョン（「read set」）に基づいてレコードを書き込むための
*宣言的な提案* としてトランザクションを扱うことで実現しています。トランザクションの
最後に、read set に含まれるすべてのバージョンが依然としてそのレコードの最新バージョンで
ある場合に限り、すべての書き込みがコミットされます。つまり、いかなる並行競合も
発生しなかったことを意味します。

では、先ほどのバージョン付き read set を使って、OCC がどのようにして上の
ソーダの大惨事を防げたのかを見てみましょう。

```
$5 Transfer                           $3 Debit Card Charge
----------------------------------------------------------
(v1, $14) <- READ Alice
(v7, $11) <- READ Bob
                                        (v1, $14) <- READ Alice
                                        WRITE Alice $11
                                        IF Alice.v = v1

WRITE Alice = $9, Bob = $16
    IF Alice.v = v1, Bob.v = v7 // 失敗！Alice は v2
```

これは、HEAD ではない状態のために Git リポジトリを push できない状況に似ています。そういう場合には、pull してから rebase するか merge するかといった対応が必要になることは、私たちは皆よく理解しています。

## OCC が負けたときに決定性が勝つ \{#when-occ-loses-determinism-wins\}

単純な楽観的同時実行制御の解決策は、Git と同じやり方で対処することです。
つまり、ユーザー／アプリケーションに競合を解決させて、再実行しても安全かどうかを判断させるというものです。

しかし Convex では、その必要はありません。トランザクションが決定的であることがわかっているからです。
Stripe で決済を実行していないし、永続的な値を書き出すためにファイルシステムへ書き込んだりもしていません。
Convex のテーブルに対して、適用されなかったいくつかの原子的な変更を提案した以外には、まったく何の効果もありませんでした。

決定的であるということは、単にトランザクションを再実行できるということを意味します。一時的なデータレースについて心配する必要はありません。
必要であれば複数回リトライを行い、競合なしにトランザクションを実行できるまで続けることができます。

<Admonition type="tip">
  実は、Git のたとえはここでも非常に適切です。OCC の競合が発生したということは、HEAD が古いために push できないということであり、変更を rebase して再度試す必要がある、という意味です。
  そして決定性こそが「マージコンフリクト」が絶対に起こらないことを保証してくれるので、（Git と違って）この rebase 操作は開発者の介入なしに必ず最終的には成功します。
</Admonition>

## スナップショット分離 vs 直列化可能性 \{#snapshot-isolation-vs-serializability\}

楽観的マルチバージョン並行制御を採用するデータベースでは、
[スナップショット分離](https://en.wikipedia.org/wiki/Snapshot_isolation) を
保証として提供することが一般的です。この
[分離レベル](https://en.wikipedia.org/wiki/Isolation_\(database_systems\)) は、
すべてのトランザクションがデータのアトミックなスナップショット上で実行されているかのように
見せかけますが、特定の並行トランザクションの組み合わせによって
誤った結果を生み出しうる
[アノマリ](https://en.wikipedia.org/wiki/Snapshot_isolation#Definition)
に対して脆弱です。Convex における楽観的並行制御の実装は、その代わりに真の
[直列化可能性](https://en.wikipedia.org/wiki/Serializability) を提供し、
どのようなトランザクションが同時に発行されたとしても正しい結果が得られます。

## これについて考える必要はありません \{#no-need-to-think-about-this\}

このアプローチの優れている点は、ミューテーション関数を「常に成功する」かのように
記述でき、かつ常に原子的に実行されることが保証されるということです。

Convex が内部でどのように動いているかという純粋な好奇心はさておき、日々の開発では
テーブルやドキュメントを変更するときに、コンフリクトやロック、原子性について
心配する必要はありません。「素直な書き方」でミューテーション関数を書けば、そのまま問題なく動作します。