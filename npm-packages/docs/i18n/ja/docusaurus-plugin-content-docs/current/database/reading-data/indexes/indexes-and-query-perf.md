---
sidebar_label: "インデックスとクエリパフォーマンス"
title: "インデックスとクエリパフォーマンス入門"
sidebar_position: 100
description: "インデックスがクエリパフォーマンスに与える影響を学ぶ"
---

Convex の
[データベースのクエリ](/database/reading-data/reading-data.mdx) を高速かつ効率的にするにはどうすればよいでしょうか？ いつ
[インデックス](/database/reading-data/indexes/indexes.md) を定義すべきでしょうか？ インデックスとは何でしょうか？

このドキュメントでは、クエリとインデックスがどのように機能するかについての単純化したモデルを説明することで、Convex におけるクエリパフォーマンスの捉え方を解説します。

すでにデータベースのクエリとインデックスについて十分な理解がある場合は、次のリファレンスドキュメントに直接進んでください。

* [データの読み取り](/database/reading-data/reading-data.mdx)
* [インデックス](/database/reading-data/indexes/indexes.md)

## ドキュメントのライブラリ \{#a-library-of-documents\}

Convex を、ドキュメントを物理的な本として保管している現実の図書館だと想像してみてください。
この世界では、[`db.insert("books", {...})`](/api/interfaces/server.GenericDatabaseWriter#insert)
で Convex にドキュメントを追加するたびに、司書がその本を棚に並べます。

デフォルトでは、Convex はドキュメントを挿入された順番に並べます。
司書が棚の左から右へ、本（ドキュメント）を順番に並べていく様子を想像してください。

次のように、最初の本を見つけるクエリを実行するとします:

```ts
const firstBook = await ctx.db.query("books").first();
```

そうすると司書は棚の左端から見ていき、最初の本を見つけることができます。これは非常に高速なクエリで、結果を得るために司書が見る必要がある本は 1 冊だけだからです。

同様に、最後に追加された本を取得したい場合は、代わりに次のようにできます。

```ts
const lastBook = await ctx.db.query("books").order("desc").first();
```

同じクエリですが、並び順を降順に入れ替えました。図書館では、司書は棚の右端から始めて右から左へと棚を見ていきます。司書は結果を判定するために 1 冊の本だけを見ればよいので、このクエリも非常に高速です。

## フルテーブルスキャン \{#full-table-scans\}

ここで、誰かが図書館に来て「ジェーン・オースティンの本はどんなものがありますか？」と尋ねたとします。

これは次のように表現できます。

```ts
const books = await ctx.db
  .query("books")
  .filter((q) => q.eq(q.field("author"), "Jane Austen"))
  .collect();
```

このクエリは「すべての本を左から右へ順番に見ていき、`author` フィールドが Jane Austen であるものを集める」という意味です。これを行うためには、司書は棚全体を順番に見て、すべての本の著者を確認する必要があります。

このクエリは、Convex がテーブル内のすべてのドキュメントを見る必要があるため、*フルテーブルスキャン* になります。このクエリのパフォーマンスは、図書館にある本の数に依存します。

Convex のテーブル内のドキュメント数が少ないうちは、これは問題ありません。ドキュメントが数百件程度であれば、フルテーブルスキャンでも十分高速です。しかし、テーブルに何千件ものドキュメントがある場合、これらのクエリは遅くなってしまいます。

図書館のたとえで言えば、この種のクエリは、図書館に棚が 1 つしかない場合には問題ありません。しかし、図書館が棚が何段もある大きな本棚になったり、本棚自体がいくつもある規模に拡張されると、この方法は現実的ではなくなります。

## カードカタログ \{#card-catalogs\}

著者がわかっているときに、その本をもっと効率的に見つけるにはどうすればよいでしょうか？

1つの方法は、図書館全体を `author` で並べ替え直すことです。これで目先の問題は解決しますが、元々の `firstBook` と `lastBook` に対するクエリは、今度はテーブル全体の走査になってしまいます。どの本が最初/最後に追加されたかを知るには、すべての本を調べる必要があるからです。

別の方法は、図書館全体を複製することです。すべての本を2冊ずつ購入し、2つの別々の棚に置きます。1つは挿入時刻順に並べ、もう1つは著者順に並べます。これは機能しますが、コストが高くつきます。図書館には今、2倍のスペースが必要になります。

より良い方法は、`author` に対して *インデックス* を作ることです。図書館では、昔ながらの [カードカタログ](https://en.wikipedia.org/wiki/Library_catalog) を使って、本を著者ごとに整理できます。この発想では、司書が各本について、次の情報を含むインデックスカードを書きます。

* 本の著者
* 本が棚のどこにあるかという場所

これらのインデックスカードは著者順に並べられ、本を収めている棚とは別の整理箱に入れておきます。カードカタログは、本ごとに1枚のインデックスカードしか持たない（本の全文を持つわけではない）ため、小さく保たれます。

![Card Catalog](/img/card-catalog.jpg)

利用者が「Jane Austen の本」を求めたとき、司書は次のようにできます。

1. カードカタログに行き、「Jane Austen」のカードをすべて素早く見つける。
2. 各カードを見て、その本を棚から探して取ってくる。

これはかなり高速です。司書は Jane Austen のインデックスカードを素早く見つけられるからです。各カードごとに本を探すのには多少の手間がかかりますが、インデックスカードの枚数は少ないので、全体としてはとても速く処理できます。

## インデックス \{#indexes\}

データベースのインデックスも同じ考え方で動作します！Convex では次のようにして
*index* を定義できます:

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  books: defineTable({
    author: v.string(),
    title: v.string(),
    text: v.string(),
  }).index("by_author", ["author"]),
});
```

すると Convex は `author` フィールドに対して `by_author` という新しいインデックスを作成します。これは、
`books` テーブルに `author` フィールドでソートされた追加のデータ構造が
保持されることを意味します。

このインデックスを使って次のようにクエリを実行できます:

```ts
const austenBooks = await ctx.db
  .query("books")
  .withIndex("by_author", (q) => q.eq("author", "Jane Austen"))
  .collect();
```

このクエリは Convex に、`by_author` インデックスを参照して
`doc.author === "Jane Austen"` であるすべてのエントリを探すよう指示しています。インデックスは
`author` でソートされているので、これは非常に効率的な操作です。つまり Convex は、このクエリを
司書が行うのと同じやり方で実行できます。

1. Jane Austen のエントリが含まれるインデックスの範囲を見つける。
2. その範囲内の各エントリに対して、対応するドキュメントを取得する。

このクエリのパフォーマンスは、
`doc.author === "Jane Austen"` となるドキュメントの数に依存しますが、それはごく少数のはずです。これで
クエリが劇的に高速になりました。

## インデックスのバックフィルと維持管理 \{#backfilling-and-maintaining-indexes\}

考えておきたい興味深い点は、この新しい構造を作成するために必要な作業です。図書館なら、司書は棚にあるすべての本を順番に確認し、著者名でソートされたカード目録に、それぞれに対応する新しいインデックスカードを差し込まなければなりません。その作業が終わって初めて、司書はカード目録が正しい結果を返すと信頼できるようになります。

Convex のインデックスでも事情は同じです。新しいインデックスを定義したとき、最初に `npx convex deploy` を実行すると、Convex はすべてのドキュメントを走査して、それぞれに対してインデックスを作成する必要があります。これが、新しいインデックスを作成した直後の最初のデプロイが、通常よりわずかに遅くなる理由です。Convex はテーブル内の各ドキュメントに対して追加の処理を行う必要があるためです。テーブルが特に大きい場合は、[staged index](/database/reading-data/indexes#staged-indexes) を使用して、バックフィルをデプロイとは別に非同期で完了させることを検討してください。

同様に、インデックスをいったん定義したあとも、データが変化するたびにそのインデックスを最新の状態に保つために、Convex は追加の作業を行う必要があります。インデックスが定義されているテーブルでドキュメントが挿入・更新・削除されるたびに、Convex は対応するインデックスエントリも更新します。これは、司書が新しい本を図書館に追加するたびに、新しいインデックスカードを作成するのと似ています。

いくつかだけインデックスを定義するのであれば、維持管理コストを心配する必要はありません。より多くのインデックスを定義すると、すべての `insert` がすべてのインデックスを更新しなければならないため、それらを維持するコストは増加します。このため、Convex ではテーブルごとのインデックス数が 32 個に制限されています。実際には、ほとんどのアプリケーションは、重要なクエリを効率よく実行するために、テーブルごとに少数のインデックスのみを定義します。

## 複数フィールドのインデックス作成 \{#indexing-multiple-fields\}

さて、図書館に利用者がやってきて、Isaac Asimov の *Foundation* を借りたいとします。`author` にインデックスがあるので、そのインデックスを使って Isaac Asimov の本をすべて見つけてから、それぞれのタイトルを調べて *Foundation* かどうかを確認できます。

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author", (q) => q.eq("author", "Isaac Asimov"))
  .filter((q) => q.eq(q.field("title"), "Foundation"))
  .unique();
```

このクエリは、司書がどのようにクエリを実行するかを説明しています。司書はカード目録を使って、Isaac Asimov の本のためのすべての索引カードを探します。カード自体には本のタイトルが書かれていないので、司書は棚にあるすべての Asimov の本を探し、それぞれのタイトルを見て *Foundation* という名前の本を見つける必要があります。最後に、このクエリは結果が最大でも 1 件であると想定しているため
[`.unique`](/api/interfaces/server.Query#unique) で終わります。

このクエリは、[`withIndex`](/api/interfaces/server.QueryInitializer#withindex) と
[`filter`](/api/interfaces/server.Query#filter) を使ったフィルタリングの違いを示しています。`withIndex` は、インデックスに基づいてクエリを制限することしかできません。特定の著者を持つすべてのドキュメントを探すといった、インデックスが効率的に実行できる操作だけが可能です。

一方で `filter` は、任意の複雑な式を書くことができますが、インデックスを使って実行されるわけではありません。代わりに、`filter` の式はインデックス範囲内のすべてのドキュメントに対して評価されます。

これらすべてを踏まえると、**インデックス付きクエリのパフォーマンスは、そのインデックス範囲内にあるドキュメントの数に依存している**と結論づけられます。この場合、司書が各本のタイトルを確認するためにそれぞれに目を通す必要があるので、パフォーマンスは Isaac Asimov の本の冊数に依存します。

残念ながら、Isaac Asimov は
[大量の本](https://en.wikipedia.org/wiki/Isaac_Asimov_bibliography_\(alphabetical\))を書いています。
現実的には 500 冊以上の本があっても、既存のインデックスを使えば Convex 上では十分高速に動作しますが、それでもどのように改善できるかを考えてみましょう。

1 つのアプローチは、`title` に対して別の `by_title` インデックスを構築することです。これにより、`.filter` と `.withIndex` で行っていた処理の役割を入れ替えて、次のようにできます。

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_title", (q) => q.eq("title", "Foundation"))
  .filter((q) => q.eq(q.field("author"), "Isaac Asimov"))
  .unique();
```

このクエリでは、インデックスを効率的に使って *Foundation* というタイトルの本をすべて探し、その中から Isaac Asimov の本を見つけています。

これは悪くはありませんが、*Foundation* というタイトルの本が多すぎる可能性があるため、依然としてクエリが遅くなるリスクがあります。さらに良いアプローチとしては、`author` と `title` の両方をインデックスする *複合*インデックスを構築することが考えられます。複合インデックスとは、フィールドの順序付きリストに対するインデックスです。

```ts noDialect title="convex/schema.ts"
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  books: defineTable({
    author: v.string(),
    title: v.string(),
    text: v.string(),
  }).index("by_author_title", ["author", "title"]),
});
```

この索引では、本はまず著者ごとに並べられ、さらに各著者の中でタイトル順に並べられています。これは、司書が索引を使って Isaac
Asimov のセクションに移動し、その中から *Foundation* を素早く見つけられることを意味します。

これを Convex のクエリで表現すると、次のようになります。

```ts
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author_title", (q) =>
    q.eq("author", "Isaac Asimov").eq("title", "Foundation"),
  )
  .unique();
```

ここでのインデックス範囲式は、著者が Isaac Asimov でタイトルが *Foundation* であるドキュメントだけを対象とするよう Convex に指示しています。これは 1 件だけのドキュメントなので、このクエリはとても高速になります。

このインデックスはまず `author`、次に `title` でソートしているため、「Isaac Asimov の著書のうち、タイトルが F で始まるものすべて」のようなクエリも効率的にサポートできます。これは次のように書けます:

```ts
const asimovBooksStartingWithF = await ctx.db
  .query("books")
  .withIndex("by_author_title", (q) =>
    q.eq("author", "Isaac Asimov").gte("title", "F").lt("title", "G"),
  )
  .collect();
```

このクエリはインデックスを使って、
`author === "Isaac Asimov" && "F" <= title < "G"` に当てはまる本を探します。ここでも、このクエリの性能は、インデックス範囲内に含まれるドキュメント数によって決まります。この場合、その範囲に入るのは頭文字が「F」の Asimov の本だけなので、ごくわずかです。

また、このインデックスは元々の「Jane Austen の本」というクエリもサポートしている点にも注意してください。インデックス範囲式で `author` フィールドだけを使い、`title` ではまったく絞り込まない、という使い方でも問題ありません。

最後に、図書館の利用者が *The Three-Body Problem* という本を探しているが、著者名は知らないという状況を想像してみてください。ここでは `by_author_title` インデックスは役に立ちません。なぜなら、まず `author` で、その次に `title` でソートされているからです。タイトル *The Three-Body Problem* は、インデックスのどの位置にも現れうるのです。

`withIndex` における Convex の TypeScript 型を見ると、インデックスのフィールドは定義された順序で比較しなければならないことが明確に分かります。インデックスが `["author", "title"]` に対して定義されているため、`title` より先に `.eq` を使って `author` を比較する必要があります。

このケースでは、このクエリを効率よく実行するために、別途 `by_title` インデックスを作成するのが最もよい選択肢と言えるでしょう。

## まとめ \{#conclusions\}

おめでとうございます！これで Convex におけるクエリとインデックスの仕組みを理解できました。

ここでは次の主要なポイントを取り上げました:

1. デフォルトでは Convex のクエリは *フルテーブルスキャン* を行います。これはプロトタイピングや小さなテーブルに対するクエリには適しています。
2. テーブルのサイズが大きくなるにつれて、*インデックス* を追加することでクエリのパフォーマンスを改善できます。インデックスは、ドキュメントを高速にクエリできるように並べ替えておくための、独立したデータ構造です。
3. Convex では、クエリは *`withIndex`* メソッドを使って、インデックスを利用するクエリの部分を表現します。クエリのパフォーマンスは、インデックス範囲式に含まれるドキュメントの数に基づいて決まります。
4. Convex は、複数のフィールドに対してインデックスを作成する *複合インデックス* もサポートしています。

クエリとインデックスについてさらに学ぶには、以下のリファレンスドキュメントを参照してください:

* [データの読み取り](/database/reading-data/reading-data.mdx)
* [インデックス](/database/reading-data/indexes/indexes.md)