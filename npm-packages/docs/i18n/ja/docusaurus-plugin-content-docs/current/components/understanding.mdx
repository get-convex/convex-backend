---
title: "コンポーネントを理解する"
slug: "understanding"
sidebar_position: 10
description: "コンポーネントを理解する"
---

Convex Components は、関数、スキーマ、データをひとまとめにした自己完結型のバックエンドモジュールです。これにより、認証、レート制限、ドキュメントの共同編集といった複雑な機能を、一からすべて実装しなくてもアプリに追加できます。

モダンな Web 開発に取り組んだことがあれば、似たようなアイデアに別の形で出会っているはずです。こうしたコンポーネントは、フロントエンドコンポーネント、サードパーティ API、サービス指向アーキテクチャから着想を得ています。重要な違いは、Convex Components がバックエンド内で動作するため、バックエンドサービスの永続性と信頼性を保ちつつ、コンポーザビリティを得られる点です。

次の図は、コンポーネントのエコシステム内でのデータおよび関数アクセスの仕組みを示しています。ある要素から別の要素への矢印は、その要素が相手の要素の関数またはデータにアクセスできることを表します。

<p style={{ textAlign: "center" }}>
  <img src="/img/components-diagram.png" alt="コンポーネントのドロップダウンのスクリーンショット" width={600} />
</p>

### データ \{#data\}

フロントエンドコンポーネントと同様に、Convex Components は状態と振る舞いをカプセル化し、
明確なインターフェースとして公開できます。ただし、メモリ内に状態を保存する代わりに、
ユーザーセッションをまたいで持続し、ユーザー間にまたがり、Webhook などの外部入力に
応じて変化する内部ステートマシンを持つことができます。コンポーネントは、いくつかの方法で
データを保存できます。

* 独自のスキーマ検証定義を持つデータベーステーブル。Convex はデフォルトでリアルタイムのため、
  データの読み取りは自動的にリアクティブになり、書き込みはトランザクションとしてコミットされます。
* メインアプリのファイルストレージとは独立したファイルストレージ。
* 組み込みの関数スケジューラを使った Durable Functions。コンポーネントは将来実行する関数を
  スケジュールし、状態を引き渡すことができます。

一般的なライブラリでは、ステートフルな既成機能を追加するにはサードパーティサービスの設定が
必要になり、状態を同じデータベースに保存する場合のようなトランザクションの保証は得られません。

### 分離性 \{#isolation\}

一般的な npm ライブラリと同様に、Convex Components には関数や型安全性が含まれており、あなたのコードから呼び出されます。ただし、それに加えて追加の保証も提供します。

* 外部サービスに似て、コンポーネント内部のコードは明示的に渡されたデータ以外を読み取ることはできません。これにはデータベーステーブル、ファイルストレージ、環境変数、スケジュールされた関数などが含まれます。逆に、コンポーネントのデータはメインアプリから直接変更されることはなく、関心の完全な分離が可能になります。
* サービス指向アーキテクチャに似て、コンポーネント内の関数は分離された環境で実行されるため、グローバル変数への書き込みやシステム動作のパッチはコンポーネント間で共有されません。
* モノリシックアーキテクチャに似て、コンポーネント呼び出し間のデータ変更はトランザクションとしてコミットされるため、複雑な分散コミットプロトコルやデータ不整合について考える必要はありません。コンポーネントがデータをコミットしたのに呼び出し元コードだけがロールバックされる、といったことは決して起こりません。
* さらに、コンポーネントへの各ミューテーション呼び出しは他の呼び出しから分離されたサブトランザクションであり、コンポーネントからスローされたエラーを安全に捕捉できます。これによりコンポーネントの作者はレースコンディションを気にせず状態変更について容易に考えることができ、スローされた例外が常にコンポーネントのサブトランザクションをロールバックすることを信頼できます。[詳細はこちら](/components/using.mdx#transactions)。

### カプセル化 \{#encapsulation\}

自分のコードをきちんと理解して筋道立てて考えられることは、コードベースを大規模化するうえで不可欠です。
コンポーネントを使うことで、API の境界や抽象化について整理して考えられるようになります。

* 上で説明したトランザクションの保証によって、コンポーネントの作者と利用者は、
  データ変更について局所的に考えられるようになります。
* コンポーネントはデータベースのテーブルへ直接アクセスするのではなく、明示的な API を公開します。
  データの不変条件は、この抽象化の境界内でコードとして強制できます。
  たとえば、[aggregate component](https://convex.dev/components/aggregate)
  は内部でデータを非正規化でき、
  [rate limiter](https://convex.dev/components/rate-limiter) コンポーネントはデータをシャーディングでき、
  [push notification](https://convex.dev/components/push-notifications)
  コンポーネントは内部で API リクエストをバッチ処理しつつ、シンプルなインターフェースを保てます。
* 実行時バリデーションにより、コンポーネント境界をまたぐすべてのデータ
  （引数と戻り値の両方）が検証されます。通常の Convex 関数と同様に、
  バリデータは TypeScript の型も指定し、実行時の保証付きでエンドツーエンドな型付けを提供します。